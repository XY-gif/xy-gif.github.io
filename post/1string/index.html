<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>1.string | 笔记</title>
<link rel="shortcut icon" href="https://xy-gif.github.io/favicon.ico?v=1682314727285">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xy-gif.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="1.string | 笔记 - Atom Feed" href="https://xy-gif.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="1.string
注：此处的string指的是std::string
（一）构造函数以及一些常用重载



类成员函数名接口
函数作用




string(const char* str)
根据字符串常量地址创造字符串


string(..." />
    <meta name="keywords" content="C++" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xy-gif.github.io">
  <img class="avatar" src="https://xy-gif.github.io/images/avatar.png?v=1682314727285" alt="">
  </a>
  <h1 class="site-title">
    笔记
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              1.string
            </h2>
            <div class="post-info">
              <span>
                2023-04-22
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://xy-gif.github.io/tag/CYVB1qPMl/" class="post-tag">
                  # C++
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="1string">1.string</h1>
<p><em>注：此处的string指的是std::string</em></p>
<h2 id="一构造函数以及一些常用重载">（一）构造函数以及一些常用重载</h2>
<table>
<thead>
<tr>
<th>类成员函数名接口</th>
<th>函数作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string(const char* str)</code></td>
<td>根据字符串常量地址创造字符串</td>
</tr>
<tr>
<td><code>string(int num,char c)</code></td>
<td>创造一个字符‘c’重复了num遍的字符串</td>
</tr>
<tr>
<td><code>string(string str)</code></td>
<td>根据另一个string拷贝</td>
</tr>
<tr>
<td><code>string(const char* str,int length)</code></td>
<td>截取字符串前length个字符作为新字符串</td>
</tr>
<tr>
<td><code>string(const char* bengin,const char* end)</code></td>
<td>截取字符串从begin开始到end不包括end，即[begin,end)</td>
</tr>
<tr>
<td><code>string(const string &amp;str,int begin,int size)</code></td>
<td>从begin处截取size个字符作为字符串</td>
</tr>
<tr>
<td><code>string operator+(string &amp;str1,string &amp;str2)</code></td>
<td>对运算符+进行重载，可以连接两个字符串</td>
</tr>
<tr>
<td><code>string &amp;operator+=(const char *s)</code></td>
<td>在原本字符串后面添加新的字符串</td>
</tr>
<tr>
<td><code>string &amp;operator+=(const char c)</code></td>
<td>与上类似</td>
</tr>
<tr>
<td><code>string &amp;operator+=(const string &amp;s)</code></td>
<td>与上类似</td>
</tr>
</tbody>
</table>
<h2 id="g的stdstringconst-char-str内容存放">g++的std::string(const char *str)内容存放</h2>
<p>1.进入构造函数先测出str长度，<br>
2.之后将长度等参数全部传入另一个函数，此处我们称为f1()<br>
3.进入f1先检测一下str是否为空，为空报错。不为空就会在进入一个函数f2()，在f2()中会给str分配空间分配的空间在堆上。<br>
5.之后把str内容复制到堆上。<br>
<em>以上是根据g++反汇编的出的大致结论，不同编译器分配策略不同，例如有的编译器可能会当字符串短时在栈上分配，字符串长时在堆上分配。</em></p>
<h2 id="getline函数">getline函数</h2>
<table>
<thead>
<tr>
<th>getline函数重载</th>
<th>函数作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>istream&amp; getline (istream&amp; is, string&amp; str)</code></td>
<td>这个重载形式从输入流中读取字符，直到遇到 EOF 或 '\n' 字符为止，并把读取到的字符存储到 str 中。</td>
</tr>
<tr>
<td><code>istream&amp; getline (istream&amp; is, string&amp; str, char delim)</code></td>
<td>这个重载形式在 istream 中查找 delim 字符，然后从字符位置开始从输入流中读取字符，直到EOF或者 delim 字符出现时停止。读取到的字符保存到字符串参数 str 中。</td>
</tr>
<tr>
<td><em>注意此处的getline不是类成员函数，就是一般函数，当然在cin等中也存在同名方法</em></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="字符串搜索">字符串搜索</h2>
<h3 id="子串搜索">子串搜索</h3>
<table>
<thead>
<tr>
<th>类成员函数接口</th>
<th>函数作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size_type find(const string &amp;str,size_type pos=0)const</code></td>
<td>从字符串pos位置向后开始查找子串str，若找到返回子串首字符在本串中出现的位置，若没找到，返回string::npos</td>
</tr>
<tr>
<td><code>size_type find(const char *str,size_type pos=0)const</code></td>
<td>与上类似</td>
</tr>
<tr>
<td><code>size_type find(const char *str,size_type pos=0,int n)const</code></td>
<td>与上类似但只在前n个字符中查找</td>
</tr>
<tr>
<td><code>size_type find(const char c,size_type pos=0)const</code></td>
<td>与第一个类似，但只查找字符</td>
</tr>
<tr>
<td><em>size_type 实际上就是unsigned int类型</em></td>
<td></td>
</tr>
<tr>
<td><em>string::npos大多数编译器将其定义为-1或者0xfffffffffffffffff，且其为公有成员变量可以直接访问</em></td>
<td></td>
</tr>
<tr>
<td><em>类成员函数声明末尾添加const，表示这个类成员函数不可以对类成员变量进行修改</em></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="其它搜索">其它搜索</h3>
<table>
<thead>
<tr>
<th>类成员函数接口</th>
<th>函数作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size_type rfind(str,size_type pos=npos)</code></td>
<td>字符串从pos位置向前搜索，若找到返回子串首字符在本串中出现的位置，若没找到，返回string::npos</td>
</tr>
<tr>
<td><code>size_type find_first_of(str,size_type pos=0)</code></td>
<td>根据str这个字符串集合中的元素，找出第一个元素出现在本字符串中的位置，若没有返回npos</td>
</tr>
<tr>
<td><code>size_type find_last_of(str,size_type pos=npos)</code></td>
<td>根据str这个字符串集合中的元素，找出最后一个元素出现在本字符串中的位置，若没有返回npos</td>
</tr>
<tr>
<td><code>size_type find_first_not_of(str,size_type pos=0)</code></td>
<td>根据str这个字符串集合中的元素，找出第一个不是str元素出现在本字符串中的位置，若没有返回npos</td>
</tr>
<tr>
<td><code>size_type find_last_not_of(str,size_type pos=npos)</code></td>
<td>根据str这个字符串集合中的元素，找出最后一个不是str元素出现在本字符串中的位置，若没有返回npos</td>
</tr>
</tbody>
</table>
<p><em>注意：pos是size_type类型也就是说npos是最大值0xfffffffffffffffff，也就是说默认从最后开始搜索</em></p>
<h2 id="字符串大小和内存大小">字符串大小和内存大小</h2>
<table>
<thead>
<tr>
<th>类成员接口</th>
<th>函数作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size_t size()</code></td>
<td>求字符串长度，也就是字符个数</td>
</tr>
<tr>
<td><code>size_t length()</code></td>
<td>同size()</td>
</tr>
<tr>
<td><code>size_t capacity()</code></td>
<td>返回对象中分配给字符串的内存大小</td>
</tr>
<tr>
<td><code>void resize(size_t n)</code></td>
<td>修改字符串长度，若n比原来的字符串长度大则原字符串后面增加'\0'，若n比原字符串长度小则截断原字符串</td>
</tr>
<tr>
<td><code>void reserve(size_t n)</code></td>
<td>修改给字符串分配的内存大小，若比原内存小则不操作，若比原内存大一般分配16*n-1的字节大小</td>
</tr>
<tr>
<td><em>reserve 也不一定分配16*n-1的大小，例如在（编译器：g++ (tdm64-1) 4.9.2，环境win11）实验时发现reserve分配的内存正好是n，这可能和编译器行为有关</em></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="字符串种类">字符串种类</h2>
<p>string是模板类basic_string模板参数实例化的类<br>
basic_string类定义大致如下：</p>
<pre><code class="language-cpp">template&lt;class charT,class char_traits&lt;charT&gt;,class Allocator = allocator&lt;charT&gt;&gt;
basic_string{...};
</code></pre>
<p>由basic_string参数实例化后产生如下的string类型</p>
<pre><code class="language-cpp">typedef basic_string&lt;char&gt; string;
typedef basic_string&lt;wchar_t&gt; wstring;
typedef basic_string&lt;char16_t&gt; u16string;    //C++11
typedef basic_string&lt;char32_t&gt; u32string;    //C++11
</code></pre>
<h2 id="线程安全性">线程安全性</h2>
<p><strong>std::string不是线程安全的</strong>，一般情况下STL的容器都不安全，这里提一嘴，之后再对线程安全性做详细学习。</p>
<h1 id="函数接口总结">函数接口总结</h1>
<table>
<thead>
<tr>
<th>string类成员函数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string(const char* str)</code></td>
</tr>
<tr>
<td><code>string(int num,char c)</code></td>
</tr>
<tr>
<td><code>string(string str)</code></td>
</tr>
<tr>
<td><code>string(const char* str,int length)</code></td>
</tr>
<tr>
<td><code>string(const char* bengin,const char* end)</code></td>
</tr>
<tr>
<td><code>string(const string &amp;str,int begin,int end)</code></td>
</tr>
<tr>
<td><code>string operator+(string &amp;str1,string &amp;str2)</code></td>
</tr>
<tr>
<td><code>string &amp;operator+=(const char *s)</code></td>
</tr>
<tr>
<td><code>string &amp;operator+=(const char c)</code></td>
</tr>
<tr>
<td><code>string &amp;operator+=(const string &amp;s)</code></td>
</tr>
<tr>
<td><code>size_type find(const string &amp;str,size_type pos=0)const</code></td>
</tr>
<tr>
<td><code>size_type find(const char *str,size_type pos=0)const</code></td>
</tr>
<tr>
<td><code>size_type find(const char *str,size_type pos=0,int n)const</code></td>
</tr>
<tr>
<td><code>size_type find(const char c,size_type pos=0)const</code></td>
</tr>
<tr>
<td><code>size_type rfind(str,size_type pos=npos)</code></td>
</tr>
<tr>
<td><code>size_type find_first_of(str,size_type pos=0)</code></td>
</tr>
<tr>
<td><code>size_type find_last_of(str,size_type pos=npos)</code></td>
</tr>
<tr>
<td><code>size_type find_first_not_of(str,size_type pos=0)</code></td>
</tr>
<tr>
<td><code>size_type find_last_not_of(str,size_type pos=npos)</code></td>
</tr>
<tr>
<td><code>size_t size()</code></td>
</tr>
<tr>
<td><code>size_t length()</code></td>
</tr>
<tr>
<td><code>size_t capacity()</code></td>
</tr>
<tr>
<td><code>void resize(size_t n)</code></td>
</tr>
<tr>
<td><code>void reserve(size_t n)</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>getline函数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>istream&amp; getline (istream&amp; is, string&amp; str)</code></td>
</tr>
<tr>
<td><code>istream&amp; getline (istream&amp; is, string&amp; str, char delim)</code></td>
</tr>
</tbody>
</table>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#1string">1.string</a>
<ul>
<li><a href="#%E4%B8%80%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E9%87%8D%E8%BD%BD">（一）构造函数以及一些常用重载</a></li>
<li><a href="#g%E7%9A%84stdstringconst-char-str%E5%86%85%E5%AE%B9%E5%AD%98%E6%94%BE">g++的std::string(const char *str)内容存放</a></li>
<li><a href="#getline%E5%87%BD%E6%95%B0">getline函数</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2">字符串搜索</a>
<ul>
<li><a href="#%E5%AD%90%E4%B8%B2%E6%90%9C%E7%B4%A2">子串搜索</a></li>
<li><a href="#%E5%85%B6%E5%AE%83%E6%90%9C%E7%B4%A2">其它搜索</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F">字符串大小和内存大小</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E7%B1%BB">字符串种类</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7">线程安全性</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E6%80%BB%E7%BB%93">函数接口总结</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xy-gif.github.io/post/2array-yu-vector/">
              <h3 class="post-title">
                2.array与vector
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://xy-gif.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
